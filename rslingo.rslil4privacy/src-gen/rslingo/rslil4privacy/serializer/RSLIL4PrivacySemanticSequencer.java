/*
 * generated by Xtext
 */
package rslingo.rslil4privacy.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import rslingo.rslil4privacy.rSLIL4Privacy.Attribute;
import rslingo.rslil4privacy.rSLIL4Privacy.Collection;
import rslingo.rslil4privacy.rSLIL4Privacy.Date;
import rslingo.rslil4privacy.rSLIL4Privacy.Disclosure;
import rslingo.rslil4privacy.rSLIL4Privacy.Enforcement;
import rslingo.rslil4privacy.rSLIL4Privacy.Import;
import rslingo.rslil4privacy.rSLIL4Privacy.Informative;
import rslingo.rslil4privacy.rSLIL4Privacy.Metadata;
import rslingo.rslil4privacy.rSLIL4Privacy.Month;
import rslingo.rslil4privacy.rSLIL4Privacy.Policy;
import rslingo.rslil4privacy.rSLIL4Privacy.PrivateData;
import rslingo.rslil4privacy.rSLIL4Privacy.RSLIL4PrivacyPackage;
import rslingo.rslil4privacy.rSLIL4Privacy.Recipient;
import rslingo.rslil4privacy.rSLIL4Privacy.RecipientPart;
import rslingo.rslil4privacy.rSLIL4Privacy.RefEnforcement;
import rslingo.rslil4privacy.rSLIL4Privacy.RefPrivateData;
import rslingo.rslil4privacy.rSLIL4Privacy.RefRecipient;
import rslingo.rslil4privacy.rSLIL4Privacy.RefRecipientSource;
import rslingo.rslil4privacy.rSLIL4Privacy.RefRecipientTarget;
import rslingo.rslil4privacy.rSLIL4Privacy.RefService;
import rslingo.rslil4privacy.rSLIL4Privacy.Retention;
import rslingo.rslil4privacy.rSLIL4Privacy.Service;
import rslingo.rslil4privacy.rSLIL4Privacy.ServicePart;
import rslingo.rslil4privacy.rSLIL4Privacy.Usage;
import rslingo.rslil4privacy.services.RSLIL4PrivacyGrammarAccess;

@SuppressWarnings("all")
public class RSLIL4PrivacySemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RSLIL4PrivacyGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == RSLIL4PrivacyPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case RSLIL4PrivacyPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.COLLECTION:
				sequence_Collection(context, (Collection) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.DATE:
				sequence_Date(context, (Date) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.DISCLOSURE:
				sequence_Disclosure(context, (Disclosure) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.ENFORCEMENT:
				sequence_Enforcement(context, (Enforcement) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.INFORMATIVE:
				sequence_Informative(context, (Informative) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.METADATA:
				sequence_Metadata(context, (Metadata) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.MONTH:
				sequence_Month(context, (Month) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.POLICY:
				sequence_Policy(context, (Policy) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.PRIVATE_DATA:
				sequence_PrivateData(context, (PrivateData) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.RECIPIENT:
				sequence_Recipient(context, (Recipient) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.RECIPIENT_PART:
				sequence_RecipientPart(context, (RecipientPart) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.REF_ENFORCEMENT:
				sequence_RefEnforcement(context, (RefEnforcement) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.REF_PRIVATE_DATA:
				sequence_RefPrivateData(context, (RefPrivateData) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.REF_RECIPIENT:
				sequence_RefRecipient(context, (RefRecipient) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.REF_RECIPIENT_SOURCE:
				sequence_RefRecipientSource(context, (RefRecipientSource) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.REF_RECIPIENT_TARGET:
				sequence_RefRecipientTarget(context, (RefRecipientTarget) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.REF_SERVICE:
				sequence_RefService(context, (RefService) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.RETENTION:
				sequence_Retention(context, (Retention) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.SERVICE_PART:
				sequence_ServicePart(context, (ServicePart) semanticObject); 
				return; 
			case RSLIL4PrivacyPackage.USAGE:
				sequence_Usage(context, (Usage) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (name=STRING description=STRING)
	 */
	protected void sequence_Attribute(EObject context, Attribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RSLIL4PrivacyPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLIL4PrivacyPackage.Literals.ATTRIBUTE__NAME));
			if(transientValues.isValueTransient(semanticObject, RSLIL4PrivacyPackage.Literals.ATTRIBUTE__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLIL4PrivacyPackage.Literals.ATTRIBUTE__DESCRIPTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAttributeAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeAccess().getDescriptionSTRINGTerminalRuleCall_4_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         condition=STRING 
	 *         partCollection=[Collection|ID]? 
	 *         (refPrivateData=RefPrivateData | refPDAll='All')? 
	 *         (refService=RefService | refSAll='All')? 
	 *         (refEnforcement=RefEnforcement | refEAll='All')? 
	 *         (modality='Permitted' | modality='Obligation' | modality='Forbidden')
	 *     )
	 */
	protected void sequence_Collection(EObject context, Collection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (day=INT month=Month year=INT)
	 */
	protected void sequence_Date(EObject context, Date semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RSLIL4PrivacyPackage.Literals.DATE__DAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLIL4PrivacyPackage.Literals.DATE__DAY));
			if(transientValues.isValueTransient(semanticObject, RSLIL4PrivacyPackage.Literals.DATE__MONTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLIL4PrivacyPackage.Literals.DATE__MONTH));
			if(transientValues.isValueTransient(semanticObject, RSLIL4PrivacyPackage.Literals.DATE__YEAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLIL4PrivacyPackage.Literals.DATE__YEAR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDateAccess().getDayINTTerminalRuleCall_0_0(), semanticObject.getDay());
		feeder.accept(grammarAccess.getDateAccess().getMonthMonthParserRuleCall_2_0(), semanticObject.getMonth());
		feeder.accept(grammarAccess.getDateAccess().getYearINTTerminalRuleCall_4_0(), semanticObject.getYear());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         condition=STRING 
	 *         partDisclosure=[Disclosure|ID]? 
	 *         (refRecipient=RefRecipient | refRAll='All')? 
	 *         (refRecipientSource=RefRecipientSource | refRSAll='All')? 
	 *         (refRecipientTarget=RefRecipientTarget | refRTAll='All')? 
	 *         (refPrivateData=RefPrivateData | refPDAll='All')? 
	 *         (refService=RefService | refSAll='All')? 
	 *         (refEnforcement=RefEnforcement | refEAll='All')? 
	 *         (modality='Permitted' | modality='Obligation' | modality='Forbidden')
	 *     )
	 */
	protected void sequence_Disclosure(EObject context, Disclosure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID enforcementName=STRING description=STRING (type='Action' | type='Algorithm' | type='Config' | type='Process' | type='Tool'))
	 */
	protected void sequence_Enforcement(EObject context, Enforcement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(EObject context, Import semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RSLIL4PrivacyPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLIL4PrivacyPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         condition=STRING 
	 *         partInformative=[Informative|ID]? 
	 *         (refPrivateData=RefPrivateData | refPDAll='All')? 
	 *         (refService=RefService | refSAll='All')? 
	 *         (refEnforcement=RefEnforcement | refEAll='All')? 
	 *         (modality='Permitted' | modality='Obligation' | modality='Forbidden')
	 *     )
	 */
	protected void sequence_Informative(EObject context, Informative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         description=STRING 
	 *         authors=STRING 
	 *         organizations=STRING 
	 *         date=Date 
	 *         version=STRING
	 *     )
	 */
	protected void sequence_Metadata(EObject context, Metadata semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RSLIL4PrivacyPackage.Literals.METADATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLIL4PrivacyPackage.Literals.METADATA__NAME));
			if(transientValues.isValueTransient(semanticObject, RSLIL4PrivacyPackage.Literals.METADATA__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLIL4PrivacyPackage.Literals.METADATA__DESCRIPTION));
			if(transientValues.isValueTransient(semanticObject, RSLIL4PrivacyPackage.Literals.METADATA__AUTHORS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLIL4PrivacyPackage.Literals.METADATA__AUTHORS));
			if(transientValues.isValueTransient(semanticObject, RSLIL4PrivacyPackage.Literals.METADATA__ORGANIZATIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLIL4PrivacyPackage.Literals.METADATA__ORGANIZATIONS));
			if(transientValues.isValueTransient(semanticObject, RSLIL4PrivacyPackage.Literals.METADATA__DATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLIL4PrivacyPackage.Literals.METADATA__DATE));
			if(transientValues.isValueTransient(semanticObject, RSLIL4PrivacyPackage.Literals.METADATA__VERSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RSLIL4PrivacyPackage.Literals.METADATA__VERSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMetadataAccess().getNameSTRINGTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMetadataAccess().getDescriptionSTRINGTerminalRuleCall_4_0(), semanticObject.getDescription());
		feeder.accept(grammarAccess.getMetadataAccess().getAuthorsSTRINGTerminalRuleCall_6_0(), semanticObject.getAuthors());
		feeder.accept(grammarAccess.getMetadataAccess().getOrganizationsSTRINGTerminalRuleCall_8_0(), semanticObject.getOrganizations());
		feeder.accept(grammarAccess.getMetadataAccess().getDateDateParserRuleCall_10_0(), semanticObject.getDate());
		feeder.accept(grammarAccess.getMetadataAccess().getVersionSTRINGTerminalRuleCall_12_0(), semanticObject.getVersion());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name='Jan' | 
	 *         name='Feb' | 
	 *         name='Mar' | 
	 *         name='Apr' | 
	 *         name='May' | 
	 *         name='Jun' | 
	 *         name='Jul' | 
	 *         name='Aug' | 
	 *         name='Sep' | 
	 *         name='Oct' | 
	 *         name='Nov' | 
	 *         name='Dec'
	 *     )
	 */
	protected void sequence_Month(EObject context, Month semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         importelements+=Import* 
	 *         metadata=Metadata? 
	 *         collection+=Collection* 
	 *         disclosure+=Disclosure* 
	 *         retention+=Retention* 
	 *         usage+=Usage* 
	 *         informative+=Informative* 
	 *         privateData+=PrivateData* 
	 *         recipient+=Recipient* 
	 *         service+=Service* 
	 *         enforcement+=Enforcement*
	 *     )
	 */
	protected void sequence_Policy(EObject context, Policy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID privateDataName=STRING description=STRING (type='PersonalInformation' | type='UsageInformation') attribute+=Attribute*)
	 */
	protected void sequence_PrivateData(EObject context, PrivateData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (recipientPart=[Recipient|ID] refs+=[Recipient|ID]*)
	 */
	protected void sequence_RecipientPart(EObject context, RecipientPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         recipientName=STRING 
	 *         description=STRING 
	 *         recipientPart+=RecipientPart* 
	 *         (scope='Internal' | scope='External' | scope='Internal/External') 
	 *         (type='Individual' | type='Organization' | type='Individual/Organization')
	 *     )
	 */
	protected void sequence_Recipient(EObject context, Recipient semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refEnforcement=[Enforcement|ID] refs+=[Enforcement|ID]*)
	 */
	protected void sequence_RefEnforcement(EObject context, RefEnforcement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refPrivateData=[PrivateData|ID] refs+=[PrivateData|ID]*)
	 */
	protected void sequence_RefPrivateData(EObject context, RefPrivateData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refRecipientSource=[Recipient|ID] refs+=[Recipient|ID]*)
	 */
	protected void sequence_RefRecipientSource(EObject context, RefRecipientSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refRecipientTarget=[Recipient|ID] refs+=[Recipient|ID]*)
	 */
	protected void sequence_RefRecipientTarget(EObject context, RefRecipientTarget semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refRecipient=[Recipient|ID] refs+=[Recipient|ID]*)
	 */
	protected void sequence_RefRecipient(EObject context, RefRecipient semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (refService=[Service|ID] refs+=[Service|ID]*)
	 */
	protected void sequence_RefService(EObject context, RefService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         condition=STRING 
	 *         partRetention=[Retention|ID]? 
	 *         period=STRING 
	 *         (refPrivateData=RefPrivateData | refPDAll='All')? 
	 *         (refService=RefService | refSAll='All')? 
	 *         (refEnforcement=RefEnforcement | refEAll='All')? 
	 *         (modality='Permitted' | modality='Obligation' | modality='Forbidden')
	 *     )
	 */
	protected void sequence_Retention(EObject context, Retention semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (servicePart=[Service|ID] refs+=[Service|ID]*)
	 */
	protected void sequence_ServicePart(EObject context, ServicePart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID serviceName=STRING description=STRING? (refPrivateData=RefPrivateData | refPDAll='All')? servicePart+=ServicePart*)
	 */
	protected void sequence_Service(EObject context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         condition=STRING 
	 *         partUsage=[Usage|ID]? 
	 *         (refPrivateData=RefPrivateData | refPDAll='All')? 
	 *         (refService=RefService | refSAll='All')? 
	 *         (refEnforcement=RefEnforcement | refEAll='All')? 
	 *         (modality='Permitted' | modality='Obligation' | modality='Forbidden')
	 *     )
	 */
	protected void sequence_Usage(EObject context, Usage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
